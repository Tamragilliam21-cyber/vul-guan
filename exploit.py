# 文件名: exploit.py
import subprocess
import re
import sys

def main():
    print("[*] Starting exploit script...")
    try:
        # 启动 /readflag 进程
        # 使用 unbuffered 模式或手动 flush 确保能及时读到输出
        p = subprocess.Popen(
            ["/readflag"],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=0
        )

        buffer = ""
        while True:
            # 逐字符读取，防止卡死
            char = p.stdout.read(1)
            if not char:
                break
            buffer += char
            # 将输出打印到标准输出，这样我们能在题目运行日志中看到
            sys.stdout.write(char)
            sys.stdout.flush()

            # 等待输入提示
            if "input your answer:" in buffer:
                break

        print("\n[*] Parsing challenge...")
        # 提取算式
        # 输出通常包含像 "((123)+(456)) input your answer:" 这样的内容
        # 我们取最后几行并尝试正则提取
        content = buffer.replace("input your answer:", "").strip()
        
        # 匹配最后出现的数学表达式
        match = re.search(r'[\d\+\-\*\/\(\)\s]+$', content)
        if match:
            equation = match.group(0)
            print(f"[*] Found equation: {equation}")
            
            # 计算结果
            try:
                answer = int(eval(equation))
                print(f"[*] Calculated answer: {answer}")
                
                # 发送答案
                p.stdin.write(f"{answer}\n")
                p.stdin.flush()
                
                # 读取剩下的输出（即 Flag）
                rest = p.stdout.read()
                print(f"\n[*] Final Output:\n{rest}")
            except Exception as e:
                print(f"[!] Eval error: {e}")
        else:
            print("[!] Could not find equation.")

    except Exception as e:
        print(f"[!] Error: {e}")

if __name__ == "__main__":
    main()
